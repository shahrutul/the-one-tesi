% this file is called up by thesis.tex
% content in this file will be fed into the main document

%: ----------------------- name of chapter  -------------------------
\chapter{Implementazione}\label{implementazione} % top level followed by section, subsection


%: ----------------------- paths to graphics ------------------------

% change according to folder and file names
\graphicspath{{5-implementazione/img/}}


%: ----------------------- contents from here ------------------------
In questa sezione verrà  descritta l'implementazione del protocollo realizzata utilizzando come base il simulatore ONE (descritto nel Capitolo \ref{simulatore}). Come prima cosa è però necessario soffermarsi su alcune modifiche che àš stato necessario eseguire sul simulatore stesso, in modo da poter poi simulare appieno il comportamento di M2MShare.

\section{Modifiche a ONE}
Come già  ampiamente descritto, M2MShare è un protocollo di peer-to-peer, adibito alla condivisione di file fra dispositivi mobili. ONE è allo stato dell'arte per quanto riguarda la simulazione del movimento e delle connessioni fra dispositivi mobili (come analizzato in \cite{panelStateDTNEvaluation}), ma abbiamo visto che possiede comunque delle limitazioni, le principali elencate nella sezione \ref{limitazioniONE}. Prima di poter realizzare un'implementazione completa di M2MShare è stato quindi necessario effettuare delle modifiche a ONE, introducendo alcune caratteristiche indispensabili a simulare il comportamento di un protocollo di peer-to-peer per lo scambio di files.

\subsection{Gestione File}
Il primo passo è stato quindi quello di dotare i vari nodi che compongono la simulazione, descritti dalla classe \textit{DTNHost}, di un file system al cui interno salvare i files oggetto delle ricerche e trasferimenti tipici di un protocollo di file sharing.

\paragraph{DTNFile}
Ogni file simulato è un'istanza della classe \textit{DTNFile}, che al suo interno contiene i campi necessari a descrivere il file stesso:

\begin{itemize}
\item Nome del file
\item Hash che lo identifica univocamente
\item Grandezza in bytes del file
\end{itemize}

Si è scelto di non inserire fra i campi anche le keywords che potrebbero descrivere il file e permettere una ricerca tramite parole chiave. Questo perché lo scopo delle simulazioni era quello di cercare e recuperare un determinato file già  noto a priori, saltando quindi la prima parte di ricerca in cui l'utente può specificare più keywords secondo effettuarla.

\paragraph{DTNFileSystem}
I vari \textit{DTNFile} in possesso di un nodo sono contenuti all'interno di un'entità  chiamata \textit{DTNFileSystem}. Come suggerisce il nome, il suo compito àš quello di simulare ad alto livello il file system del device rappresentato dal nodo. La realizzazione àš basilare, con i files condivisi contenuti in un'unica directory e delle funzioni che permettono le operazioni di:
\begin{itemize}
\item ottenere il numero di files contenuti
\item verificare la presenza di un determinato DTNFile, utilizzando il suo hash come criterio di ricerca
\item recuperare il riferimento di un determinato DTNFile
\item recuperare una \textit{Collection} contenente tutti i riferimenti ai files presenti nel file system
\item inserire un nuovo \textit{DTNFile} nel file system
\end{itemize}

Lo presenza del file system simulato, rappresentato da un'istanza della classe DTNFileSystem, all'interno di un determinato nodo àš dipendente dalla configurazione adottata per la simulazione, come descritto nella sezione \ref{configurazioneONE}. Per aumentare la flessibilità  a seconda della simulazione desiderata, sono stati quindi aggiunti due parametri di configurazione:
\begin{description}
\item[Scenario.simulateFiles] àš un parametro booleano che indica se simulare o meno la presenza di un file system nei nodi e la seguente distribuzione di files contenuti.
\item[Group.fileCapability] è un parametro booleano che indica se un determinato gruppo di nodi ha la possibilità  o meno di utilizzare un file system per contenere dei files. Un gruppo di nodi rappresentante dei mezzi di trasporto pubblici, ad esempio, non avrà  necessità  di gestire la presenza di files al proprio interno.
\end{description}

\paragraph{DTNFileGenerator}
\label{fileGeneratorImplementazione}
Per simulare la distribuzione di files fra i vari nodi, all'inizio della simulazione, è stato creato un generatore che, a partire da uno o più files di input, crea i vari \textit{DTNFiles} e li distribuisce fra i nodi, a seconda di quanto configurato.
\\
Ogni file di input può contenere più \textit{DTNFileCreationRequest}, ognuna delle quali descrive il \textit{DTNFile} da creare e come distribuirlo fra i nodi della simulazione. Una \textit{DTNFileCreationRequest} contiene al proprio interno:
\begin{itemize}
\item tipo di distribuzione fra i nodi
\item nome del \textit{DTNFile} da creare
\item dimensione in bytes del \textit{DTNFile} da creare
\item numero di copie da creare e distribuire
\item nodi (singoli) a cui distribuire il \textit{DTNFile}
\item gruppi di nodi a cui distribuire il \textit{DTNFile}
\end{itemize}

Gli ultimi tre parametri vengono utilizzati a seconda del tipo di distribuzione che dovrà  essere applicata al file. I nodi interessati sono solamente quelli in cui è abilitata la simulazione del file system, cioè quelli appartenenti a gruppi in cui il parametro \textit{fileCapability} ha valore \textit{true}. I tipi di distribuzione possibili sono:
\begin{description}
\item[A] (all): il file viene copiato per il numero di volte specificato e distribuito casualmente fra tutti i nodi
\item[G] (groups): il file viene copiato per il numero di volte specificato e distribuito casualmente solo fra i nodi appartenenti ai gruppi specificati
\item[P] (percent): il file viene copiato per la percentuale indicata relativa al totale dei nodi e distribuito casualmente fra tutti i nodi
\item[H] (hosts): il file viene copiato e distribuito solo fra i nodi selezionati. Se uno dei nodi indicati non ha attiva la simulazione del file system (\textit{fileCapability = false}), viene lanciata un'eccezione gestita dal simulatore che provvede a terminare subito la simulazione informando l'utente dell'errore di configurazione.
\end{description}

Di seguito sono presentati alcuni esempi di configurazione, per la creazione e distribuzione di \textit{DTNFiles}, che possono venire caricati dal \textit{DTNFileGenerator}.

\begin{center}
\textbf{A	mySong.mp3	3.5M	50}
\end{center}
Indica di creare un \textit{DTNFile}, di dimensione 3,5 MB e nome "mySong.mp3", e di distribuirlo casualmente in 50 copie fra tutti i nodi con \textit{fileCapability = true}.
\\

\begin{center}
\textbf{P	aPhoto.jpg	5M	25}
\end{center}
Indica di creare un \textit{DTNFile}, di dimensione 5.0 MB e nome "aPhoto.jpg", e di distribuirlo casualmente fra il 25\% dei nodi con \textit{fileCapability = true}.
\\

\begin{center}
\textbf{G	aPhoto.jpg	2.4M	25	6	8	10}
\end{center}
Indica di creare un \textit{DTNFile}, di dimensione 2,4 MB e nome "aPhoto.jpg", e di distribuirlo casualmente in 25 copie fra tutti i nodi appartenenti ai soli gruppi 6, 8 e 10
\\

\begin{center}
\textbf{H	ebook.pdf	650k	42	43	44}
\end{center}
Indica di creare un \textit{DTNFile}, di dimensione 650 kB e nome "ebook.pdf", e di distribuirlo fra i nodi con indirizzo pari a 42, 43 e 44, una copia per nodo.
\\

Come già  accennato, è fondamentale che l'esecuzione di una simulazione sia riproducibile, sia per verificare i dati e i risultati ottenuti, sia per poterne variare un parametro, mantenendo però costante il comportamento del resto del sistema simulato. Questo ragionamento si applica anche alla casualità  presente all'interno del \textit{DTNFileGenerator}, ossia alla distribuzione delle varie copie dei \textit{DTNFile} fra i nodi.
\\
Per garantire che, effettuando più simulazioni utilizzando la medesima configurazione, i files vengano distribuiti agli stessi nodi, è stata adottata la stessa tecnica utilizzata dai modelli di movimento che estendono la classe \textit{MovementModel}. In quel caso i moduli relativi al movimento vengono inizializzati utilizzando un parametro di configurazione relativo al seed per il \textit{random number generator}. Nel caso di valori di configurazione e seed iniziale mantenuti immutati, i nodi si muovono nello stesso modo anche ripetendo più volte la simulazione: vengono infatti generati gli stessi valori relativi a destinazioni, velocità  e tempi di attesa per i nodi.
\\
If the seed and all the movement model related settings are kept the same, all nodes should 
move the same way in different simulations (same destinations, speed and wait time values are used).


\paragraph{FileRequest}
A \textit{FileRequest} represents the user request for a particular file. In every instance of this class are included:
\begin{itemize}
\item \textbf{fromAddr}: the address of the node operated by the user looking for the file
\item \textbf{filename}: the name of the file searched
\item \textbf{creationTime}: the simulated time when the request s submitted by the user 
\end{itemize}
All \textit{FileRequests} are read by the \textit{M2MShareFileRequestReader} at the beginning of every simulation, then during the simulation, when simulated time become equal to the \textit{creationTime} of the \textit{FileRequests}, that is inserted into the correct queue of the node corresponding to the address included in the request.

\paragraph{M2MShareFileRequestReader}
It is the entity responsible for reading the \textit{FileRequests} at the beginning and to dispatch the requests during the simulation, when the correct time comes. It implements the interface \textit{EventQueue}, and so it provides the method \textit{nextEventsTime()}, which returns when the next request will be ready to be inserted in the corresponding node, and the method \textit{nextEvent()}, which returns the next request that will become active.


\subsection{GUI}
The GUI of THE\_ONE has been modified to reflect the addition of file simulation support to the simulator. The detail window related to a node, show using the button \"Routing info\" now contains informations about the file system of the node, including all the complete files owned and the percent of VirtualFiles already downloaded. 
\figuremacro{Routing-Info}{Routing Info}{An example of window with a detailed view of a node state}{}

\subsection{Reports}
A fundamental feature related to simulations is the capability of gathering data from different aspects of the simulated world, like positions of nodes, communications, data transfers and so on. To achieve this goal in THE\_ONE are used some special modules named \textit{Report Generators} which works with some related Listeners to catch the interested events in the simulated scenario and save them to some report files.
The main objectives of our simulations was to gather informations about the efficiency of delegations and file division strategies, and to do so we collected data about several aspects for every simulation. We now describe the report modules created to the gathering of data during the simulations, specifying the type and mode of data collection used.

\paragraph{FileGatheringLog}
The first report module is a log report module, that store the selected events in a list, saving the to file one event per line. This module is responsible to listen for the following events:
\begin{itemize}
\item \textbf{VirtualFile creation:} a new \textit{VirtualFile} has been created due to the execution of a \textit{FileRequest} in a node. It emulate a user requesting a new file to be found and downloaded.
\item \textbf{DTNPendingDownload creation:} a new \textit{DTNPendingDownload} has been created in a servant peer due to the delegation of a task from a client node.
\item \textbf{DTNPendingDownload completion:} a \textit{DTNPendingDownload} has been completed in a servant peer (the servant has downloaded all the requested file interval subject of the delegated task). Consequently a \textit{DTNDownloadFWD} has been created and enqueue in the servant.
\item \textbf{DTNPendingDownload expiration:} a \textit{DTNPendingDownload} has expired in a servant peer before it was completed (the servant has not downloaded all the requested file interval subject of the delegated task).
\item \textbf{DTNDownloadFWD expiration:} a \textit{DTNDownloadFWD} has expired in a servant peer before it was completed (the servant has not forwarded all the requested file interval subject of the delegated task to the requester node).
\item \textbf{DTNDownloadFWD completion:} a \textit{DTNDownloadFWD} has been completed in a servant peer (the servant has forwarded all the requested file interval subject of the delegated task to the requester node).
\end{itemize}

Every event is saved in the following format:
\begin{center}
\textit{Sim\_time	event\_description	event\_details}
\end{center}
The following are some examples:

\begin{center}
\textbf{15538.0000	PendingDownload	A32 to E476}
\end{center}
Is referred to the task delegation from the node A32 to the node E467, 15538 seconds after the start of the simulation.
\\

\begin{center}
\textbf{38559.5000 PendingDownload completed in F630 (317200191 requested by A32)}
\end{center}
Is referred to the completion of the \textit{DTNPendingDownload} in the servant node F630 at time 38559.5. It was delegated by the node A32 and the id of the searched file was \textit{317200191}
\\

\begin{center}
\textbf{213738.0000	DownloadFWD expired in F523 (317200191 requested by A32)}
\end{center}
Is referred to the expiration of the \textit{DownloadFWD} in the servant node F523 at time 213738. It was delegated by the node A32 and the id of the searched file was \textit{317200191}
\\

\paragraph{DataTransferLog}
\textit{DataTransferLog} module is another log module, which keep track of events regarding data transfer between nodes in the simulation. These can occur during the execution of several activities:
\begin{itemize}
\item \textbf{VirtualFile:} when the requester peer is in range with a node carrying the searched file, and the data transfer take place. Multiple data transfer events can be generated, if there are several peers with the searched file in range.
\item \textbf{DTNPendingDownload:} when a servant peer downloads, from a node carrying the searched file, some requested intervals contained in the delegated task.
\item \textbf{DTNDownloadFWD:} when a servant peer forwards the result of a delegated \textit{DTNPendingDownload} to the client peer.
\end{itemize}
Data transfer events are saved in the following format:
\begin{center}
\textit{Sim\_time	from\_address	to\_address	data\_transferred (in bytes)}
\end{center}
e.g.
\begin{center}
\textbf{98829.0000	G714	A17	2750001}
\end{center}
Is referred to the data transfer from node G714 to node A17, 98829 seconds after the start of the simulation.
\\

\paragraph{FileGatheringReport}
\textit{DataTransferLog} module is the most important report module used during our simulations, because it summarizes all key aspects of a single simulation. In detail, these are the values tracked by this module:
\begin{itemize}
\item \textbf{Total data:}	the total amount of data traffic exchanged between servant peers trying to satisfy a delegated task, file possessor peers and the data forwarding quantity toward the requestor node.
\item \textbf{VirtualFile created:}	number of \textit{VirtualFile} task created during the simulation
\item \textbf{VirtualFile delegated:} how many times a \textit{VirtualFile} task has been delegated to a servant peer
\item \textbf{PendingDownloads completed:} how many of the delegated tasks have been completed i.e. how many times the servant peer has been able to find and download all the data intervals requested in the \textit{DTNPendingDownload} 
\item \textbf{PendingDownloads expired:} how many of the delegated tasks expired before the servant peer being able to find and download all the data intervals requested in the \textit{DTNPendingDownload} 
\item \textbf{DownloadFWDs expired:} how many \textit{DownloadFWDs} expired i.e. the servant peer downloaded all the data intervals requested in the \textit{DTNPendingDownload} but it was not able to forward them to the requester peer before the task expiration
\item \textbf{DownloadFWDs returned:} how many \textit{DownloadFWDs} has been forwarded correctly to the requester peer
\item \textbf{VirtualFile completed:} how many of the created \textit{VirtualFile} has been completed
\item \textbf{First VirtualFile satisfied:}	the time (in seconds) passed from the beginning of the simulation before the first \textit{VirtualFile} has been completed
\item \textbf{Simulated time:} the simulated duration (in seconds) of the simulation
\item \textbf{Simulation time:}	the real duration of the simulation (in seconds)
\end{itemize}
Saving all these values for every simulation is useful to make some \textit{a posteriori} analysis like averages, minimum and maximum values and to find best or worst case for a large number of simulations, as will be shown in section \ref{analisiLabel}.


\paragraph{DelegationGraphvizReport}
The last report module implemented for our simulation is a module responsible for the creation of reports describing the delegation history of the simulation using a Graphwiz graph. These graphs are described using the DOT language and can be displayed using the \textit{Graphwiz Graph Visualization Software}\footnote{http://www.graphviz.org/}. These graphs are useful to get a visual feedback about the delegations of tasks done and the status of that tasks, especially in case of multi-hop delegations. For every peer involved in delegations can be seen:
\begin{itemize}
\item if it receive the delegation (obviously)
\item if it complete the delegated task
\item if it forwarded back the result of the delegated task
\end{itemize}
In figure \ref{graph-example}
\figuremacro{graph-example}{Graphviz graph example}{An example of graph generated using the output of DelegationGraphvizReport module}{}


\section{M2MShare Implementation}
In this section will be described the implementation of the modules composing M2MShare into THE\_ONE. As said earlier in Section \ref{simulatore}, every routing protocol is an extension of a common superclass named \textit{MessageRouter} and, according to the THE\_ONE philosophy, every new routing module can be inserted extending that class and it can be consequently used in configuration time to set the routing behaviour of nodes.
\\

M2MShare implementation consists in the main class extending \textit{MessageRouter}, named \textit{M2MShareRouter}, and several other classes contained into the package \textit{routing.m2mShare}.

\subsection{M2MShareRouter}
As earlier said, this is the main class of M2MShare implementation. Its first responsibility is to load the related settings as set in configuration files (see Section \ref{configurazioneONE}) and initializes all the modules needed to the execution of the protocol. These are the entities which will be later described and are responsible of the different aspects of the protocol. Values used to initialize the settings are read from configuration files and are all included in the settings namespace \textit{M2MShareRouter}. Every parameter have a default value, used in case it is not specified in any configuration file. Here are shown the available parameters and, shown in brackets, the relative default value:
\begin{itemize}
\item \textbf{M2MShareRouter.frequencyThreshold [2]} indicates the minimum number of encounter times needed for elect as servant a peer and consequently delegate to him a task
\item \textbf{M2MShareRouter.scanFrequency [10]} indicates how many seconds the \textit{PresenceCollector} have to wait between a scan and the next one
\item \textbf{M2MShareRouter.delegationType [1]} indicates the type of delegation strategy used. It accept three values:
\begin{itemize}
\item \textbf{0:} do not use delegation and file exchange is initiated only when a peer holding the requested data file is found in reach area 
\item \textbf{1:} use the M2MShare technique where missing tasks are delegated only to peers which exceed the \textit{frequencyThreshold} value
\item \textbf{2:} use the trivial technique where missing tasks are delegated to each encountered peer
\end{itemize}
\item \textbf{M2MShareRouter.fileDivisionType [1]} indicates the type of file division strategy used. It accept three values:
\begin{itemize}
\item \textbf{0:} for every file transfer is requested the entire file
\item \textbf{1:} use the M2MShare technique to choose the initial download point in the requested file
\item \textbf{2:} randomly choose the initial download point in the requested file
\end{itemize}
\item \textbf{M2MShareRouter.useBroadcastModule [true]} used to enable/disable the broadcast module. Could be useful to speed-up simulations, at the cost of a loss of precision
\item \textbf{M2MShareRouter.delegationDepth [1]} indicates the maximum times a task can be delegated, starting from the initial requester
\item \textbf{M2MShareRouter.stopOnFirstFileRequestSatisfied [false]} used to make the simulation stop when the first File Request has been satisfied. Can be useful in simulations in which we are not interested in what happens after the File Request satisfaction
\end{itemize}

The class \textit{M2MShareRouter} also extends the superclass \textit{MessageRouter} and doing so it override the main method of this class: \textit{update()}. As said in Section \ref{esecuzioneONE}, that method is called one time for every simulated time interval, after the update of movement and connections of the node. In \textit{M2MShareRouter} the only action executed in \textit{update()} is to call the method \textit{runUpdate()} in module \textit{Scheduler}, described in section \ref{schedulerImplementazione}.

\subsection{PresenceCollector}
The module \textit{PresenceCollector} is responsible of gathering information about in-reach area devices and to track encounters between other nodes to realize the election strategy selected for the current node in the simulation.

\subsection{QueuingCentral}

\subsection{Activity}
\paragraph{VirtualFile}
\paragraph{DTNPendingDownload}
\paragraph{DTNDownloadFwd}

\subsection{Scheduler}
\label{schedulerImplementazione}
\paragraph{Executor}
\paragraph{Communicator}

\subsection{BroadcastModule}

\subsection{IntervalMap}
 
% ---------------------------------------------------------------------------
%: ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------

