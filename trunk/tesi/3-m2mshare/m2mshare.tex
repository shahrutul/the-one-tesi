% this file is called up by thesis.tex
% content in this file will be fed into the main document

%: ----------------------- name of chapter  -------------------------
\chapter{M2MShare}\label{m2mshare} % top level followed by section, subsection


%: ----------------------- paths to graphics ------------------------

% change according to folder and file names
%\graphicspath{{2-Consorzi/images/}}


%: ----------------------- contents from here ------------------------
\textbf{La parte principale: si parla del protocollo
Differenza di operare in una DTN rispetto ad una rete tradizionale
importanza del routing e delle deleghe}
\\


\section{DTN module}
DTNs are particularly useful in situations with intermittent connectivity and there are long and unpredictable intervals in contacts between nodes. Routing protocols developed for and used in the Internet are not suitable for adoption in mobile networks, where every node has a limited connection range and high mobility. These factors make difficult, and sometime impossible, to establish an end-to-end connection between source and destination nodes in a communication.
\\

In a Peer to Peer application is also fundamental to have an high availability of shared files, to ensure the recovery of a file searched. This implies the needs for a high number of simultaneously connected nodes, which we saw is not so obvious in a mobile network.
\\

To overcome these limitations, M2MShare uses an asynchronous communication strategy in which a \textit{client} peer, which is in search for a file, can delegate to another peer, a \textit{servant}, the task of search for the file and return it to the requester. Delegation system is at the root of M2MShare. This permits to widely extend the area where to look for the searched file, in a network composed by spread and poorly connected nodes.
\\

Before proceeding further it can be useful to explain in what a delegation action consists. A delegation is the action performed by a client peer which \textit{asks} to a servant peer to execute some unaccomplished task of its own. This unaccomplished task can be a query, composed by several keywords, for which the client want to receive a list of files which satisfies it. To accomplish this task, the servant schedules it for a later execution and searches between shared files in encountered nodes for some file satisfying the query. When the pending task is completed, the servant creates a new task type, a forward task. The objective of this kind of task is to return the output of a pending task to the requester node.
\\
One task can be delegated by the client to several servant peers and this allow to use nodes mobility as an advantage instead of a negative factor. A client node can virtually enter in contact range with nodes that it would instead never meet. 
\\

All delegated task has also a Time To Live (TTL) value. If a delegated task is not completed and its result has not been returned to the client within its TTL value, the task expires and it is not scheduled again for execution in the servant.
\\

\subsection{Servant Election}
Tee entire task life-cycle is done in an infrastructure-less environment, where routing path is dynamically created during execution. 

Visto che tutto il ciclo di vita di un task, dalla creazione alla delega al ritorno del risultato, si svolge in un ambiente infrastructure-less, in cui il percorso dei dati viene creato dinamicamente durante l'esecuzione, è fondamentale una scelta oculata riguardo a chi delegare un proprio task insoddisfatto. 
\\
Delegare un task a tutti i nodi incontrati, infatti, non è la scelta più conveniente, visto che si tradurrebbe in un prevedibile spreco di traffico oltre che di energia, fattore da non sottovalutare in un ambiente mobile in cui i nodi hanno un autonomia non certo infinita.
\\
Un possibile fattore da valutare potrebbero essere gli interessi in comune: come analizzato in \cite{socialNetworks}, riguardo alla diffusione di dati, un nodo potrebbe diffondere dati differenti a seconda del nodo che incontra. Se è un amico, allora potrebbe essere conveniente diffondere i dati relativi ai loro interessi comuni, mentre se è uno sconosciuto allora i dati diffusi potrebbero essere i più lontani dai loro interessi comuni.
\\

Una volta delegato il task, poi è indispensabile che il risultato del task venga ritornato al client, una volta completato, altrimenti tutto il lavoro svolto è stato inutile. L'idea di base utilizzata in M2MShare è quindi quella di eleggere come servant dei nodi che ci si aspetta di incontrare di nuovo. Come visto anche nella sezione \ref{descrWDM} relativa al modello di movimento WDM, le attività quotidiane di una persona, possono generalmente lasciare trasparire una routine di fondo rispetto agli spostamenti e alle persone incontrate. Si vengono spontaneamente a creare delle \textit{comunità} temporanee all'interno delle quali le persone si incontrano con regolarità: ad esempio dei colleghi entrano in contatto ogni giorno in ufficio, dei pendolari utilizzano gli stessi mezzi pubblici per spostarsi alla mattina verso il luogo di lavoro e alla sera per tornare a casa, ecc..
\\

Una persona adatta ad essere eletta come servant è quindi una persona incontrata frequentemente. Per valutare quindi quanto spesso si entra in contatto con un altro device, M2MShare utilizza un demone chiamato \textit{PresenceCollector}, descritto nella sezione \ref{descrPresenceCollector}. Questo demone è incaricato di tenere traccia del numero di volte che il client è entrato in contatto con ogni altro nodo. Per fare ciò, effettua delle scansioni ad intervalli regolari, tenendo traccia dei nodi presenti all'interno del raggio di comunicazione. Una volta che il numero di incontri supera un parametro detto \textit{Frequency Threshold}, il nodo viene eletto come servant e il client può delegarvi dei task.
\\

La frequenza delle scansioni del \textit{PresenceCollector} è un parametro importante, in quanto influenza sia la probabilità di un nodo di essere eletto come servant (con scansioni più frequenti il numero di incontri per nodo cresce più rapidamente rispetto all'utilizzare una frequenza di scansione minore), sia il consumo energetico del client (scansioni più frequenti implicano un consumo maggiore). In M2MShare la frequenza di scan del \textit{PresenceCollector} è un parametro regolabile dall'utente, mentre uno sforzo aggiuntivo è stato fatto nel regolare automaticamente il valore della \textit{Frequency Threshold}.
\\

Questa è infatti l'altro parametro che influenza pesantemente le probabilità per un nodo di venire eletto come servant: con una \textit{Frequency Threshold} bassa, bastano pochi incontri affinché un nodo la superi e venga quindi eletto, rischiando di delegare un task ad un servant che verrà rincontrato con scarsa probabilità. Con una \textit{Frequency Threshold} troppo elevata invece è possibile che molti nodi promettenti vengano scartati.
\\

M2MShare utilizza quindi un algoritmo di tuning che, all'inizio di ogni giorno, regola il valore della \textit{Frequency Threshold} in base a quanto osservato nel giorno precedente, rispetto al numero di servants eletti e ad un altro parametro, detto \textit{Probation Window}. Affinché un nodo venga considerato periodico, il numero degli incontri con esso, in un periodo di tempo pari al valore della \textit{Probation Window}, deve essere superiore alla \textit{Frequency Threshold}. Quindi se il valore della \textit{Probation Window} diventa troppo elevato (pochi nodi vengono eletti), si procede a ridurre la \textit{Frequency Threshold}, rendendo così più probabile l'elezione di nodo a servant dopo un minor numero di incontri. Viceversa se il numero di servants attivi è superiore alle previsioni si provvede a diminuire il valore della \textit{Probation Window}. Quando anche questo raggiunge il minimo (impostato a 2 giorni), si procede ad incrementare la \textit{Frequency Threshold}.
\\

La lista contenente il numero di incontri per nodo, utilizza poi una tecnica di rimpiazzo in modo da garantire un consumo contenuto di memoria, garantendo allo stesso tempo agli altri nodi una possibilità di venire eletti come servants. Il criterio utilizzato per decidere se un nodo deve restare o meno nella lista è quello di valutare da quanto tempo vi è inserito: se un nodo viene eletto come servant, allora viene tolto dalla lista in quanto divenuto attivo, ma se un nodo è presente nella lista da un periodo di tempo superiore al valore della \textit{Probation Window}, allora anche in questo caso viene tolto, per dare la possibilità ad altri nodi di essere monitorati e magari venire eletti. Infine, nel caso la lista sia piena ogni nuovo nodo incontrato viene scartato, finché non si libera un posto grazie all'elezione di un nuovo servant o a causa della politica di rimpiazzo descritta.

\section{Modulo di ricerca}
Prima di poter cominciare il recupero di un file interessante per l'utente, \`{e} fondamentale che il sistema sappia che file cercare, fra quelli disponibili nella rete. Il modulo incaricato di assolvere questo compito \`{e} modulo di ricerca.
\\

Ogni device mantiene un repository in cui sono contenute informazioni relative ai file condivisi con gli altri utenti che utilizzano M2MShare. Queste informazioni includono nome del file, dimensione, posizione nel file system e un hash che lo identifica unicamente nella rete. Questo ultimo valore \`{e} particolarmente utile quando la ricerca ha come oggetto un file specifico, rispetto ad una serie di files, permettendo quindi una efficiente query con una risposta di tipo booleano (file presente \/ non presente nel repository).
\\
Oltre alla ricerca orientata al singolo file, il modulo di ricerca permette anche quella tramite l'uso di keywords specificate dall'utente. Per permettere ci\`{o} viene utilizzata anche una strategia di indicizzazione comune nell'Information Retrieval, ossia quella dell'\textit{Inverted Index}: ogni file \`{e} indicizzato sotto un certo numero di termini contenuti nella sua descrizione e durante la ricerca \`{e} fra questi termini che il modulo andrà a cercare nel caso di richiesta. 


\section{Modulo di Trasporto}
Il modulo di trasporto è probabilmente quello più complesso fra i moduli che compongono M2MShare. I suoi compiti spaziano dal gestire il ciclo di vita di un task (dalla creazione al termine passando per la delega), gestire la memoria utilizzata, fino alla gestione delle code di attività e la loro esecuzione.

\subsection{Sistema di accodamento}
Durante l'esecuzione di M2MShare, un nodo può trovarsi a dover eseguire numerose attività derivanti da deleghe ricevute da altri nodi e da task create dall'utente utilizzatore del device stesso. Idealmente ogni attività dovrebbe essere eseguita in un thread dedicato, operando così in parallelo alle altre attività. Questo non è praticamente conveniente, in quanto comporterebbe un utilizzo troppo elevato di memoria, per dei dispositivi come quelli mobili in cui le risorse a disposizione sono limitate. 
\\

Per risolvere questo problema M2MShare utilizza un sistema di accodamento in cui, non appena un task viene creato (dal nodo stesso o in seguito a delega), viene subito accodato in una delle code di attività disponibili e schedulato per la successiva esecuzione. In questo modo le varie attività vengono eseguite in maniera sequenziale, a seconda del tipo. Non tutte le attività vengono gestite infatti con la stessa priorità e diverse strategie vengono adottate a seconda della coda in cui un task viene accodato.
\\

Il componente dedicato alla gestione delle code di attività è il \textit{QueuingCentral}, che contiene al suo interno le seguenti code, ognuna delle quali contiene al suo interno attività con caratteristiche diverse:

\begin{description}
\item[dtnDownloadQueue:] contiene al suo interno task remoti indicanti che un servant ha completato un task delegato in precedenza.
\item[dtnPendingQueue:] contiene al suo interno task delegati da altri verso il nodo corrente, che per questi funge da servant.
\item[dtnPendingUpload:] contiene i task delegati da altri, che il nodo corrente ha terminato e di cui è pronto a ritornare il risultato.
\item[queryQueue:] contiene le query eseguite dall'utente del nodo per la ricerca di files.
\item[uploadQueue:] contiene le richieste di dati verso altri nodi.
\item[virtualFileQueue:] contiene le richieste di download di file inserite dall'utente del nodo.
\end{description}

Il \textit{QueuingCentral} è anche responsabile di definire delle policy riguardanti la memoria da assegnare alla memorizzazione dei task nelle code, definendo quindi un limite alle deleghe ricevute e al numero massimo di trasferimenti da effettuare.

\subsection{Scheduler ed esecuzione di un task}
Lo \textit{Scheduler} è il componente incaricato di schedulare, come suggerisce il nome, l'esecuzione delle varie attività contenute nelle code del \textit{QueuingCentral}. I vari task vengono smistati fra quattro \textit{execution flows}:

\begin{description}
\item[triggered\_activity\_flow,] che interessa i task contenuti nella \textit{dtnPendingUpload}. Viene eseguito ogni volta che il \textit{PresenceCollector} effettua una scansione dei dispositivi presenti nelle vicinanze, in modo da poter eventualmente ritornare il risultato di un task delegato al nodo corrente.
\item[local\_activity\_flow,] che interessa i task contenuti nelle code \textit{dtnDownloadQueue}, \textit{virtualFileQueue} e \textit{queryQueue}. Viene data priorità ai task contenuti nella \textit{dtnDownloadQueue}, in quanto rappresentano dei task delegati per i quali i rispettivi servants sono pronti a ritornare il risultato.
\item[pending\_activity\_flow,] che interessa le attività contenute nella \textit{dtnPendingQueue}, ossia i task delegati da altri al nodo corrente. 
\item[upload\_activity\_flow,] che interessa le attività contenute nella \textit{uploadQueue}.
\end{description}

Una volta che un task pronto per essere eseguito viene estratto dalla coda in cui si trova, la sua esecuzione è gestita da un'entità detta \textit{Executor}. Questa è un demone attivo presente nel sistema, che è incaricato fra l'altro di gestire anche il numero di esecuzioni parallele di un singolo task: può infatti capitare, per alcuni tipi di attività come i VirtualFile, che l'esecuzione consista nel download simultaneo di parti di file da diverse fonti presenti nel raggio di comunicazione. In questo caso ogni trasferimento è gestito da una distinta entità detta \textit{Communicator}, entità presenti in numero limitato all'interno di ogni nodo.

\subsection{Tipi di task}
\textbf{vale la pena descriverli?}

\section{Modulo di Routing}
\section{Modulo MAC}

\subsection{Presence Collector} 
\label{descrPresenceCollector}

\section{File Division Strategy}
\label{descrFileDivisionStrategy}
 
% ---------------------------------------------------------------------------
%: ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------

