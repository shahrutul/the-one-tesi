% this file is called up by thesis.tex
% content in this file will be fed into the main document

%: ----------------------- name of chapter  -------------------------
\chapter{M2MShare}\label{m2mshare} % top level followed by section, subsection


%: ----------------------- paths to graphics ------------------------

% change according to folder and file names
%\graphicspath{{2-Consorzi/images/}}


%: ----------------------- contents from here ------------------------
\textbf{La parte principale: si parla del protocollo
Differenza di operare in una DTN rispetto ad una rete tradizionale
importanza del routing e delle deleghe}
\\


\section{DTN module}
DTNs are particularly useful in situations with intermittent connectivity and there are long and unpredictable intervals in contacts between nodes. Routing protocols developed for and used in the Internet are not suitable for adoption in mobile networks, where every node has a limited connection range and high mobility. These factors make difficult, and sometime impossible, to establish an end-to-end connection between source and destination nodes in a communication.
\\

In a Peer to Peer application is also fundamental to have an high availability of shared files, to ensure the recovery of a file searched. This implies the needs for a high number of simultaneously connected nodes, which we saw is not so obvious in a mobile network.
\\

To overcome these limitations, M2MShare uses an asynchronous communication strategy in which a \textit{client} peer, which is in search for a file, can delegate to another peer, a \textit{servant}, the task of search for the file and return it to the requester. Delegation system is at the root of M2MShare. This permits to widely extend the area where to look for the searched file, in a network composed by spread and poorly connected nodes.
\\

Before proceeding further it can be useful to explain in what a delegation action consists. A delegation is the action performed by a client peer which \textit{asks} to a servant peer to execute some unaccomplished task of its own. This unaccomplished task can be a query, composed by several keywords, for which the client want to receive a list of files which satisfies it. To accomplish this task, the servant schedules it for a later execution and searches between shared files in encountered nodes for some file satisfying the query. When the pending task is completed, the servant creates a new task type, a forward task. The objective of this kind of task is to return the output of a pending task to the requester node.
\\
One task can be delegated by the client to several servant peers and this allow to use nodes mobility as an advantage instead of a negative factor. A client node can virtually enter in contact range with nodes that it would instead never meet. 
\\

All delegated task has also a Time To Live (TTL) value. If a delegated task is not completed and its result has not been returned to the client within its TTL value, the task expires and it is not scheduled again for execution in the servant.
\\

\subsection{Servant Election}
The entire task life-cycle is done in an infrastructure-less environment, where routing path is dynamically created during execution. So it is important to choose wisely which peers can be elected as servants.
\\

The simpler choice could be to delegate an unaccomplished task to every met node. This could not be a good strategy in servant election. Delegating a task to every met node would be very expensive in bandwidth usage and in energy consumption. These factors are very important in a mobile environment where nodes have limited energy autonomy. 
\\

A possible solution would be to analyse common interest between client and other peers. In \cite{socialNetworks} is shown a strategy for data diffusion in which a node share only some kind of data to another node, accordingly to their common interests and relationship. If the other peer is a friend it could be convenient to share data related to their common interests. If the other is not a friend node the client node should share data the most different from their common interests.
\\

When the task has been delegated is then fundamental that its result is forwarded back to the client. Otherwise the delegation would be useless. M2MShare strategy is to elect as servants only nodes that we expect to meet again. As we will see in Section \ref{descrWDM}, related to Working Day Movement model, one person daily activities can highlight a repetitiveness in movements and met people. Spontaneous and temporary \textit{communities} are created by people which met between them regularly, e.g. colleagues which work in the same office, commuters which use the same transportation to reach their work place, etc.. ecc..
\\

M2MShare idea is that a frequently encountered person is a person that we will probably meet again and so it is a good candidate to servant election. To evaluate how frequently a node meet another node, M2MShare uses an active daemon called \textit{PresenceCollector}, described in Section \ref{descrPresenceCollector}. This daemon traces the number of encounters, scanning at regular intervals for other nodes in communication range. When the number of encounters with another node exceeds the value of a parameter called \textit{Frequency Threshold}, that node is elected as servant.
\\

The numbers of encounters with other peers are saved in a list with limited length. This limitation is adopted to guarantee a small memory usage. To allow each peer the possibility to serve as servant, a replacement strategy is adopted for entries in encounter list. When a peer is elected as servant, its entry is removed from the list. If a peer is not elected as a servant and its entry is in the list from a long time period then its removed from the list. The maximum time a peer can be in the list without being elected as servant is related to a value called \textit{Probation Window}. If the list is full and a new peer is encountered, its information is discarded. A new peer can enter in the list only when a slot is freed y the replacement strategy.

\section{Search module}
Before a user can choose what file to download from the network, is must know what files are shared by other users and find between them what it is looking for. Every peer in the network maintains a local repository of files shared with other M2MShare users. For every file are available informations about file name, dimension, position in local file system and an hash value that identifies univocally that file in the network.
\\

There are two kinds of file queries: 

\begin{description}
\item[unique file query]: a single file is searched and a boolean answer (present / not present) is needed.
\item[keyword query]: the user ask for a list of files satisfying some keyword included in the query.
\end{description}

To satisfy a keyword query, M2MShare uses the Inverted index list strategy. Every shared file is indexed under a finite number of terms contained in the file description text and during a query execution the Search module looks in these terms for files suitable for the response.


\section{Modulo di Trasporto}
Il modulo di trasporto è probabilmente quello più complesso fra i moduli che compongono M2MShare. I suoi compiti spaziano dal gestire il ciclo di vita di un task (dalla creazione al termine passando per la delega), gestire la memoria utilizzata, fino alla gestione delle code di attività e la loro esecuzione.

\subsection{Sistema di accodamento}
Durante l'esecuzione di M2MShare, un nodo può trovarsi a dover eseguire numerose attività derivanti da deleghe ricevute da altri nodi e da task create dall'utente utilizzatore del device stesso. Idealmente ogni attività dovrebbe essere eseguita in un thread dedicato, operando così in parallelo alle altre attività. Questo non è praticamente conveniente, in quanto comporterebbe un utilizzo troppo elevato di memoria, per dei dispositivi come quelli mobili in cui le risorse a disposizione sono limitate. 
\\

Per risolvere questo problema M2MShare utilizza un sistema di accodamento in cui, non appena un task viene creato (dal nodo stesso o in seguito a delega), viene subito accodato in una delle code di attività disponibili e schedulato per la successiva esecuzione. In questo modo le varie attività vengono eseguite in maniera sequenziale, a seconda del tipo. Non tutte le attività vengono gestite infatti con la stessa priorità e diverse strategie vengono adottate a seconda della coda in cui un task viene accodato.
\\

Il componente dedicato alla gestione delle code di attività è il \textit{QueuingCentral}, che contiene al suo interno le seguenti code, ognuna delle quali contiene al suo interno attività con caratteristiche diverse:

\begin{description}
\item[dtnDownloadQueue:] contiene al suo interno task remoti indicanti che un servant ha completato un task delegato in precedenza.
\item[dtnPendingQueue:] contiene al suo interno task delegati da altri verso il nodo corrente, che per questi funge da servant.
\item[dtnPendingUpload:] contiene i task delegati da altri, che il nodo corrente ha terminato e di cui è pronto a ritornare il risultato.
\item[queryQueue:] contiene le query eseguite dall'utente del nodo per la ricerca di files.
\item[uploadQueue:] contiene le richieste di dati verso altri nodi.
\item[virtualFileQueue:] contiene le richieste di download di file inserite dall'utente del nodo.
\end{description}

Il \textit{QueuingCentral} è anche responsabile di definire delle policy riguardanti la memoria da assegnare alla memorizzazione dei task nelle code, definendo quindi un limite alle deleghe ricevute e al numero massimo di trasferimenti da effettuare.

\subsection{Scheduler ed esecuzione di un task}
Lo \textit{Scheduler} è il componente incaricato di schedulare, come suggerisce il nome, l'esecuzione delle varie attività contenute nelle code del \textit{QueuingCentral}. I vari task vengono smistati fra quattro \textit{execution flows}:

\begin{description}
\item[triggered\_activity\_flow,] che interessa i task contenuti nella \textit{dtnPendingUpload}. Viene eseguito ogni volta che il \textit{PresenceCollector} effettua una scansione dei dispositivi presenti nelle vicinanze, in modo da poter eventualmente ritornare il risultato di un task delegato al nodo corrente.
\item[local\_activity\_flow,] che interessa i task contenuti nelle code \textit{dtnDownloadQueue}, \textit{virtualFileQueue} e \textit{queryQueue}. Viene data priorità ai task contenuti nella \textit{dtnDownloadQueue}, in quanto rappresentano dei task delegati per i quali i rispettivi servants sono pronti a ritornare il risultato.
\item[pending\_activity\_flow,] che interessa le attività contenute nella \textit{dtnPendingQueue}, ossia i task delegati da altri al nodo corrente. 
\item[upload\_activity\_flow,] che interessa le attività contenute nella \textit{uploadQueue}.
\end{description}

Una volta che un task pronto per essere eseguito viene estratto dalla coda in cui si trova, la sua esecuzione è gestita da un'entità detta \textit{Executor}. Questa è un demone attivo presente nel sistema, che è incaricato fra l'altro di gestire anche il numero di esecuzioni parallele di un singolo task: può infatti capitare, per alcuni tipi di attività come i VirtualFile, che l'esecuzione consista nel download simultaneo di parti di file da diverse fonti presenti nel raggio di comunicazione. In questo caso ogni trasferimento è gestito da una distinta entità detta \textit{Communicator}, entità presenti in numero limitato all'interno di ogni nodo.

\subsection{Tipi di task}
\textbf{vale la pena descriverli?}

\section{Modulo di Routing}
\section{Modulo MAC}

\subsection{Presence Collector} 
\label{descrPresenceCollector}
La frequenza delle scansioni del \textit{PresenceCollector} è un parametro importante, in quanto influenza sia la probabilità di un nodo di essere eletto come servant (con scansioni più frequenti il numero di incontri per nodo cresce più rapidamente rispetto all'utilizzare una frequenza di scansione minore), sia il consumo energetico del client (scansioni più frequenti implicano un consumo maggiore). In M2MShare la frequenza di scan del \textit{PresenceCollector} è un parametro regolabile dall'utente, mentre uno sforzo aggiuntivo è stato fatto nel regolare automaticamente il valore della \textit{Frequency Threshold}.
\\

Questa è infatti l'altro parametro che influenza pesantemente le probabilità per un nodo di venire eletto come servant: con una \textit{Frequency Threshold} bassa, bastano pochi incontri affinché un nodo la superi e venga quindi eletto, rischiando di delegare un task ad un servant che verrà rincontrato con scarsa probabilità. Con una \textit{Frequency Threshold} troppo elevata invece è possibile che molti nodi promettenti vengano scartati.
\\

M2MShare utilizza quindi un algoritmo di tuning che, all'inizio di ogni giorno, regola il valore della \textit{Frequency Threshold} in base a quanto osservato nel giorno precedente, rispetto al numero di servants eletti e ad un altro parametro, detto \textit{Probation Window}. Affinché un nodo venga considerato periodico, il numero degli incontri con esso, in un periodo di tempo pari al valore della \textit{Probation Window}, deve essere superiore alla \textit{Frequency Threshold}. Quindi se il valore della \textit{Probation Window} diventa troppo elevato (pochi nodi vengono eletti), si procede a ridurre la \textit{Frequency Threshold}, rendendo così più probabile l'elezione di nodo a servant dopo un minor numero di incontri. Viceversa se il numero di servants attivi è superiore alle previsioni si provvede a diminuire il valore della \textit{Probation Window}. Quando anche questo raggiunge il minimo (impostato a 2 giorni), si procede ad incrementare la \textit{Frequency Threshold}.
\\



\section{File Division Strategy}
\label{descrFileDivisionStrategy}
 
% ---------------------------------------------------------------------------
%: ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------

