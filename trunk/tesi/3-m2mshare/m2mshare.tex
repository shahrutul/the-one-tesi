% this file is called up by thesis.tex
% content in this file will be fed into the main document

%: ----------------------- name of chapter  -------------------------
\chapter{M2MShare}\label{m2mshare} % top level followed by section, subsection


%: ----------------------- paths to graphics ------------------------

% change according to folder and file names
%\graphicspath{{2-Consorzi/images/}}


%: ----------------------- contents from here ------------------------
\textbf{La parte principale: si parla del protocollo
Differenza di operare in una DTN rispetto ad una rete tradizionale
importanza del routing e delle deleghe}
\\
Mobility and low node density require a revision of networking protocols toward a delay tolerant approach. In this section we expose some operational details of M2MShare, the application we designed and implemented to demonstrate the opportunistic DTN approach in mobile to mobile multimedia content sharing.

M2Mshare uses the Bluetooth to create a P2P overlay networks, which would allow the automatic exchange of multimedia content among smartphones. Our software automatically initiates a search by broadcasting the user’s query request toward other Bluetooth enabled devices operating the program. Once the answer/s is received, data found to match the criteria will be automatically requested for download. All this process is done without the user mediation; the user only needs to specify the search terms, configurable through the user interface and chose from the matched content list. Key features of M2MShare are its ease of use and autonomy, once the initial preferences are set up no further user interaction is needed and the user can find downloaded files directly on her/his phone, when done.
Given that energy consumption is a problem for handheld devices the notion of active sessions was introduced. An active session is a period of time in which the software is functional and performs its duties and such periods are configurable through the graphical user interface. This way, the user can set the application to look for requested contents only in certain periods of the day; for instance, when commuting or during lunch time in the cafeteria, so as to be active only when it could be useful since the high number of other peers around.

M2MSHare uses node mobility to reach data content on other local disconnected networks. This is achieved by introducing an asynchronous communication model, store-delegate-and-forward where a peer delegates and unaccomplished/unsatisfied task to other peers in the overlay network. Delegating tasks to all encountered peers is energy and bandwidth consuming. Also, it would be useless to assign tasks to peers that will never be met again in the future. To avoid this M2MShare exploits social relations and delegates tasks only to frequently encountered peers, peers whom are expected to be encountered again in the future.

We could say that we exploit social relations among users to determine possible task delegates. This is not a new approach as context and social relations are already studied in opportunistic data transmission. Yet, we utilize even unknown social relations by connecting users that have to pass by the same geographical location at the same time frequently enough. To assume that a candidate for task delegation could be met again in the future (so that she/he will be able to deliver contents possibly found), we use as an heuristic the history of previous encounters.

\section{DTN module}
DTNs are particularly useful in situations with intermittent connectivity and there are long and unpredictable intervals in contacts between nodes. Routing protocols developed for and used in the Internet are not suitable for adoption in mobile networks, where every node has a limited connection range and high mobility. These factors make difficult, and sometime impossible, to establish an end-to-end connection between source and destination nodes in a communication.
\\

In a Peer to Peer application is also fundamental to have an high availability of shared files, to ensure the recovery of a file searched. This implies the needs for a high number of simultaneously connected nodes, which we saw is not so obvious in a mobile network.
\\

To overcome these limitations, M2MShare uses an asynchronous communication strategy in which a \textit{client} peer, which is in search for a file, can delegate to another peer, a \textit{servant}, the task of search for the file and return it to the requester. Delegation system is at the root of M2MShare. This permits to widely extend the area where to look for the searched file, in a network composed by spread and poorly connected nodes.
\\

Before proceeding further it can be useful to explain in what a delegation action consists. A delegation is the action performed by a client peer which \textit{asks} to a servant peer to execute some unaccomplished task of its own. This unaccomplished task can be a query, composed by several keywords, for which the client want to receive a list of files which satisfies it. To accomplish this task, the servant schedules it for a later execution and searches between shared files in encountered nodes for some file satisfying the query. When the pending task is completed, the servant creates a new task type, a forward task. The objective of this kind of task is to return the output of a pending task to the requester node.
\\
One task can be delegated by the client to several servant peers and this allow to use nodes mobility as an advantage instead of a negative factor. A client node can virtually enter in contact range with nodes that it would instead never meet. 
\\

All delegated task has also a Time To Live (TTL) value. If a delegated task is not completed and its result has not been returned to the client within its TTL value, the task expires and it is not scheduled again for execution in the servant.
\\

\subsection{Servant Election}
The entire task life-cycle is done in an infrastructure-less environment, where routing path is dynamically created during execution. So it is important to choose wisely which peers can be elected as servants.
\\

The simpler choice could be to delegate an unaccomplished task to every met node. This could not be a good strategy in servant election. Delegating a task to every met node would be very expensive in bandwidth usage and in energy consumption. These factors are very important in a mobile environment where nodes have limited energy autonomy. 
\\

A possible solution would be to analyse common interest between client and other peers. In \cite{socialNetworks} is shown a strategy for data diffusion in which a node share only some kind of data to another node, accordingly to their common interests and relationship. If the other peer is a friend it could be convenient to share data related to their common interests. If the other is not a friend node the client node should share data the most different from their common interests.
\\

When the task has been delegated is then fundamental that its result is forwarded back to the client. Otherwise the delegation would be useless. M2MShare strategy is to elect as servants only nodes that we expect to meet again. As we will see in Section \ref{descrWDM}, related to Working Day Movement model, one person daily activities can highlight a repetitiveness in movements and met people. Spontaneous and temporary \textit{communities} are created by people which met between them regularly, e.g. colleagues which work in the same office, commuters which use the same transportation to reach their work place, etc.. ecc..
\\

M2MShare idea is that a frequently encountered person is a person that we will probably meet again and so it is a good candidate to servant election. To evaluate how frequently a node meet another node, M2MShare uses an active daemon called \textit{PresenceCollector}, described in Section \ref{descrPresenceCollector}. This daemon traces the number of encounters, scanning at regular intervals for other nodes in communication range. When the number of encounters with another node exceeds the value of a parameter called \textit{Frequency Threshold}, that node is elected as servant.
\\

The numbers of encounters with other peers are saved in a list with limited length. This limitation is adopted to guarantee a small memory usage. To allow each peer the possibility to serve as servant, a replacement strategy is adopted for entries in encounter list. When a peer is elected as servant, its entry is removed from the list. If a peer is not elected as a servant and its entry is in the list from a long time period then its removed from the list. The maximum time a peer can be in the list without being elected as servant is related to a value called \textit{Probation Window}. If the list is full and a new peer is encountered, its information is discarded. A new peer can enter in the list only when a slot is freed y the replacement strategy.

\section{Search module}
Before a user can choose what file to download from the network, is must know what files are shared by other users and find between them what it is looking for. Every peer in the network maintains a local repository of files shared with other M2MShare users. For every file are available informations about file name, dimension, position in local file system and an hash value that identifies univocally that file in the network.
\\

There are two kinds of file queries: 

\begin{description}
\item[unique file query]: a single file is searched and a boolean answer (present / not present) is needed.
\item[keyword query]: the user ask for a list of files satisfying some keyword included in the query.
\end{description}

To satisfy a keyword query, M2MShare uses the Inverted index list strategy. Every shared file is indexed under a finite number of terms contained in the file description text and during a query execution the Search module looks in these terms for files suitable for the response.


\section{Transport module}
Ciclo di vita di un task
memory management
queuing system
come viene serializzato un task


Provides the task queuing mechanism and task lifecycle management. We discuss about the necessity of resource management given the fact that mobile devices are resource constraint and extend our solution to this. An important part of this section is the communication protocol that individual tasks implement along with a detailed analysis of the data packets exchanged during communication. Finally, we introduce the file division strategy and provide some test results that demonstrate its efficiency over other division strategies

A peer device operating M2MShare might receive simultaneous incoming requests for
upload and delegations from other peers, on the same time issue his own requests.
Parallel requests processing means that each request being processed is handled in a
separate execution flow. This modus operandi can easily cause a relatively large
memory utilization that, due to the limited device resources, can cause the application to
crash;

Another feature that was deemed important was to distinguish between different kinds
of tasks, as this would allow different policies to be applied to different types of
requests. In order to manage inter and intra-queue requests, local and global policies
were needed. Local policies regulate the way that tasks are handled within one specific
queue, whereas global policies regulate the manner in which the various queues are
processed. These considerations are implemented in the current release by providing a
default processing policy.
The QueuingCentral is the component that implements our queuing strategy

Il modulo di trasporto è probabilmente quello più complesso fra i moduli che compongono M2MShare. I suoi compiti spaziano dal gestire il ciclo di vita di un task (dalla creazione al termine passando per la delega), gestire la memoria utilizzata, fino alla gestione delle code di attività e la loro esecuzione.

\subsection{Sistema di accodamento}
Durante l'esecuzione di M2MShare, un nodo può trovarsi a dover eseguire numerose attività derivanti da deleghe ricevute da altri nodi e da task create dall'utente utilizzatore del device stesso. Idealmente ogni attività dovrebbe essere eseguita in un thread dedicato, operando così in parallelo alle altre attività. Questo non è praticamente conveniente, in quanto comporterebbe un utilizzo troppo elevato di memoria, per dei dispositivi come quelli mobili in cui le risorse a disposizione sono limitate. 
\\

Per risolvere questo problema M2MShare utilizza un sistema di accodamento in cui, non appena un task viene creato (dal nodo stesso o in seguito a delega), viene subito accodato in una delle code di attività disponibili e schedulato per la successiva esecuzione. In questo modo le varie attività vengono eseguite in maniera sequenziale, a seconda del tipo. Non tutte le attività vengono gestite infatti con la stessa priorità e diverse strategie vengono adottate a seconda della coda in cui un task viene accodato.
\\

Il componente dedicato alla gestione delle code di attività è il \textit{QueuingCentral}, che contiene al suo interno le seguenti code, ognuna delle quali contiene al suo interno attività con caratteristiche diverse:

\begin{description}
\item[dtnDownloadQueue:] contiene al suo interno task remoti indicanti che un servant ha completato un task delegato in precedenza.
\item[dtnPendingQueue:] contiene al suo interno task delegati da altri verso il nodo corrente, che per questi funge da servant.
\item[dtnPendingUpload:] contiene i task delegati da altri, che il nodo corrente ha terminato e di cui è pronto a ritornare il risultato.
\item[queryQueue:] contiene le query eseguite dall'utente del nodo per la ricerca di files.
\item[uploadQueue:] contiene le richieste di dati verso altri nodi.
\item[virtualFileQueue:] contiene le richieste di download di file inserite dall'utente del nodo.
\end{description}

Il \textit{QueuingCentral} è anche responsabile di definire delle policy riguardanti la memoria da assegnare alla memorizzazione dei task nelle code, definendo quindi un limite alle deleghe ricevute e al numero massimo di trasferimenti da effettuare.

\subsection{Scheduler ed esecuzione di un task}
Lo \textit{Scheduler} è il componente incaricato di schedulare, come suggerisce il nome, l'esecuzione delle varie attività contenute nelle code del \textit{QueuingCentral}. I vari task vengono smistati fra quattro \textit{execution flows}:

\begin{description}
\item[triggered\_activity\_flow,] che interessa i task contenuti nella \textit{dtnPendingUpload}. Viene eseguito ogni volta che il \textit{PresenceCollector} effettua una scansione dei dispositivi presenti nelle vicinanze, in modo da poter eventualmente ritornare il risultato di un task delegato al nodo corrente.
\item[local\_activity\_flow,] che interessa i task contenuti nelle code \textit{dtnDownloadQueue}, \textit{virtualFileQueue} e \textit{queryQueue}. Viene data priorità ai task contenuti nella \textit{dtnDownloadQueue}, in quanto rappresentano dei task delegati per i quali i rispettivi servants sono pronti a ritornare il risultato.
\item[pending\_activity\_flow,] che interessa le attività contenute nella \textit{dtnPendingQueue}, ossia i task delegati da altri al nodo corrente. 
\item[upload\_activity\_flow,] che interessa le attività contenute nella \textit{uploadQueue}.
\end{description}

Una volta che un task pronto per essere eseguito viene estratto dalla coda in cui si trova, la sua esecuzione è gestita da un'entità detta \textit{Executor}. Questa è un demone attivo presente nel sistema, che è incaricato fra l'altro di gestire anche il numero di esecuzioni parallele di un singolo task: può infatti capitare, per alcuni tipi di attività come i VirtualFile, che l'esecuzione consista nel download simultaneo di parti di file da diverse fonti presenti nel raggio di comunicazione. In questo caso ogni trasferimento è gestito da una distinta entità detta \textit{Communicator}, entità presenti in numero limitato all'interno di ogni nodo.


\section{Modulo di Routing}
Provides message forwarding capabilities in our overlay network and implements a controlled flooding technique alike AODV. Here we discuss about overlay organization - how overlay connections are established and maintained along with some insights on some implementation details

\section{Modulo MAC}
Provides service discovery and message broadcast facility for peers in our network. In this section our focus is concentrated in a fundamental service called PresenceCollector which periodically gathers presence information about in-reach area devices. We discuss the importance of the periodic inquiry and introduce a theorem that can be used to compute the average transferred data quantity between two devices. Finally, we conclude our discussion by introducing the BroadcastService giving some implementation considerations

\subsection{Presence Collector} 
\label{descrPresenceCollector}
The \textit{PresenceCollector} is the daemon which periodically scans the network for in-reach area devices. Encounters data resulting from these scans is used to evaluate if a peer is a frequent encountered peer and eventually elect it as a servant.
\\

Scan frequency is a very important parameter. It influences energy consumption and probability for another peer to be elected as a servant. The presence collector is always active, so an high scan frequency is not reasonable because it results in a network bandwidth and device energy waste. Also, an high frequency results in a high probability for a node to be elected as a servant: the number of encounters raise and the \textit{frequency threshold} is exceeded faster than with a low scan frequency value.
\\

While scan frequency can be set by the user, additional efforts have been done to automatically tune the \textit{Frequency Threshold} value. This is the other parameter that affects the probability  for a node to be elected as a servant: few encounters are enough, with a low value, to exceed the threshold value. If the value is too low, we could delegate task that we would never meet again, resulting in never forwarded results of the task. On the other hand, with a high \textit{Frequency Threshold} value, many promising peers could be rejected from being servants.
\\

At the beginning of every day, M2MShare uses a tuning algorithm which adapts the \textit{Frequency Threshold} value according to what observed during the previous day. Considered values are the number of elected peers and \textit{Probation Window} value. A peer is considered frequently encountered if it is met a number of times great than the \textit{Frequency Threshold} in a period as long as the \textit{Probation Window} value. After this period, if a peer has not been yet elected, it is removed from the encounter list. If \textit{Probation Window} value is high and few nodes are elected, \textit{Frequency Threshold} is lowered, making more probable for a node to be elected. On the other hand, if the number of elected peers is too high, \textit{Probation Window} is lowered. When its value reaches the minimum value (set to 2 days), \textit{Frequency Threshold} is raised.


\section{File Division Strategy}
\label{descrFileDivisionStrategy}
Bluetooth file transfer applications usually adopt a client-server paradigm where devices pair with each other for all the duration of data transfer. If the transfer is interrupted, exchanged data are of no use. This because every file transfer have to start from the beginning. 
\\

In a mobile environment such as the one where M2MShare operates, disconnections between nodes are very frequent. The standard file transfer strategy is not suitable for this environment, because pairing for all the duration of data exchange could be very difficult. We must remember that M2MShare should be entirely user transparent, so the user should not worry about file transfers. Data exchange should run automatically whenever possible and the transfer strategy should adopt transfer resume.
\\

M2MShare provide a file division strategy where files are divided in intervals of variable size. The file is seen as map of non overlapping intervals of variable length that need to be downloaded. So, when a node asks another node for a file, it asks only not yet downloaded intervals. If a disconnection occurs, the download can restart downloading the remaining not yet downloaded intervals.
\\

One of the characteristics of this file division strategy is the starting point of file transfers. If every file transfer starts from the beginning of the file, with several file possessors in reach area, there would be overlapping downloaded intervals downloaded. Overlapping data is of no use, creating redundancy, and M2MShare file division strategy tries to minimize that redundancy. This is done by assigning a different \textit{download map} to each file possessor. A download map is a list of not yet downloaded intervals, with a starting point which identifies the interval from where to initiate fetching data. The starting point is calculated considering the number of intervals the file is composed of, the file length and the index of the next interval to be fetched. For additional details refer to \cite{tesiarmir}.
\\

The fact that each file possessor is asked for the file starting from different points allows reconstructing the whole file even if just part of it is downloaded from each of them. When the requested interval has been downloaded, if the file possessor is still in reach, the rest of the map is requested. In case of task delegation, a data download might be delegated to a servant peer, and in such a case the entire download map is communicated to the servant device.
 
 
% ---------------------------------------------------------------------------
%: ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------

